本题要利用深度优先搜索：也就是给定一个起始点 从这个起始点开始 尽可能的在满足条件的前提下 往最深的找 直到找不到
      但是由于会出现 当前节点走不通 需要返回上一个节点 重新开始走 所以就需要回溯
    
    本题思路：要定义一个深度搜索加回溯的函数，这个函数输入矩阵word 矩阵位置索引 单词位置索引 返回bool
            用一个二层for循环 使用这个函数 就能从矩阵的每个点开始
            在这个函数中 如果超出了界限或者当前点不相等就返回false 一旦k值等于字长 就返回true
            然后 对于中间的字符 没找到一个就把当前的路径记录 标为、0 说明此路已经走过 然后深度搜索：
             (myexist(board,word,i+1,j,k+1) || myexist(board,word,i-1,j,k+1) || myexist(board,word,i,j+1,k+1) || myexist(board,word,i,j-1,k+1))
             意思是 只要有一个满足就继续走下去 
             直到走到最后 如果没有任何一条路径存在 就会返回false 并且 依次把标记的路径还原：board[i][j]=word[k];
             如果右路径满足 就会返回true 并且也会还原路径 但是由于已经是true了 所以可以直接跳出循环
             
          所以本题：深度搜索是用来找每一条可能的路径，回溯是用来还原每一条找过的路径，不至于影响下一次的寻找。
          
       在本题编程中，要注意：
        在private中说明了int的定义 在publice中直接使用就行 不用重新用int定义 否则会让private中的定义默认为0   并且还说明了在private中要用public的数据 需要先定义声明
        注意在for循环里可以这样写：if(myexist(board,word,i,j,0))   return true;  这样每次都会运行if里面的函数 但是否跳出由它结果确定
          
