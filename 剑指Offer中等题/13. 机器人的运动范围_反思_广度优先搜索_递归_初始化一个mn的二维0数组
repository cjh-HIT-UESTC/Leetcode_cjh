首先本题 要理解题意：要知道如何利用行列索引来计算对应的分数值 ：就是利用取余和除法 模拟一下就能知道
  
  然后从00位置开始，进行搜索，并且不能跳  所以很容易的就能感受到广度搜索的影子  
    现在来说一下广度搜索和深度搜索：其实二者差不多，一个在于要一层一层的找，一个在于直接找最深的
    其代码核心都是采用递归的模式，并需要进行走过的路径的标记（这点很重要！！！！可以标记为“、0”或者-1等等）
        一旦当前点是走过的地方，那么就不访问此地（返回0） 否则就访问此地，并标记
      
      但是要注意的一点是：是否需要把标记抹去（变回原来的值），这取决于当前路径走不通的情况下，是否还需要走以前去过的地方看看
     
     代码核心：利用递归，利用与或运算，输入下一次可能的位置:i+1,j+1等等   
     
     在本题中：还学会了怎么初始化一个全0的二维数组：vector<vector<int>> vec(m,vector<int>(n,2))
     
     类似的一维数组的初始化：vector<int>vec(n,0)
     
   在本题中，我还学会了如何思考定义一个我迭代操作需要的函数 ：需要分析需求，先分析输入：如本题 输入的就是当前位置的索引   然后因为要计数 所以返回0和1
