首先 要了解什么是前序中序后序遍历
前序遍历：也就是第一个肯定为根节点 然后左树 再右树 先左后右（有左一直左）
中序遍历：即根节点在中间 左边是左子树 右边是右子树  

利用这样的性质就能递归构造二叉树：主要思想是 找到每一层的根节点
      
      先利用前序遍历确定第一个根节点   再用这个节点在中序遍历中 查找对应的位置索引 然后就可以知道 左子树和右子树的中序遍历
      根据左子树右子树的中序遍历长度  就可以在前序遍历中 确定第一个根节点的左右节点的前序遍历
      这样就能：一个函数 输入是他的前序遍历和中序遍历 返回的是当前的根节点
              递归这个函数 ：输入这个根节点的左右节点的前序遍历和中序遍历 得到这两个中序节点 
              返空条件是：一旦前序遍历为空（前序和中序长度一样）
        这样就能 不断递归了
        
        要注意的细节：
            定义根节点要用new 并且给它的是当前前序遍历的第一个节点：TreeNode* root=new TreeNode(*preorder.begin());
            还要注意：vector< int >::iterator it=find(inorder.begin(),inorder.end()，*preorder.begin());
                      find这样对vector用 返回的是一个迭代器  可以使用auto代替迭代器定义
                 注意给新定义的容器赋值：vector<int>inorderleft(inorder.begin(),it);   利用迭代器
              
  利用哈希表加速：
  要注意 应该在函数外定义这个哈希表，所以要：private:  
        并且要重新定义函数   在这里要注意这个新定义的函数 输入的时候要多输入前序中序的左右位置索引  并以此为结束标志
        
    主要思想是：不改变一开始的数组长度，利用固定的哈希表，根据不同的位置索引来进行操作
              关键在于 每次重新跟新前序遍历的起始位置  和 中序遍历的起始位置
              
       所以，第一种方法是，不断改变输入的数组，第二种是不断改变数组的起始位置索引（因为用了哈希表，索引数组不能动）
    
