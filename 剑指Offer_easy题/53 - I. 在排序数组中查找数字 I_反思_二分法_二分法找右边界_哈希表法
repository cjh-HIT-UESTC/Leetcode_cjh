首先 本题肯定是需要遍历完全部元素的 所以必然时间复杂度为ON

因为是顺序查找 所以自然的想到了 二分查找 
那么第一种想法：先二分查找到任意一个目标值的位置索引 然后利用这个索引再向两边遍历 找到所有满足条件的数的个数
    第二种想法：二分查找这个目标值的右边界，并把它封装成一个函数 然后用这个函数查找这个数的右边界减去这个数-1的右边界 即可
    
    对于二分查找 需要注意的是：
   循环条件是：while(left<=right)   之所以在这里有等于 是因为左右边界并不是用来判断后就不需要了 而是目标值也可能在左右边界上 所以需要等于
   对于查找右边界：一旦找到相等的值 就让左边界上移一位 直到左边界超过右边界 这样返回左边界 就是右边界的索引
   
   对于在类中封装函数 需要注意新定义的函数的位置 

第三种方法是利用哈希表：构建int int型的哈希表 记录每个数出现的次数
    unordered_map<int,int>map;
    然后利用for循环 遍历数组中每个数：for(int num:nums)
    然后把每个数当作键 并把它们对应的个数++：  ++map[num]    注意是中括号【】
    
    然后只要返回目标数字的个数即可：map[target]
