本题重要的是理解住题意 从开始一直加 只要不小于0就还可能加到一个大的数 一旦小于0了 说明后续就没机会了 于是返回0（代表从下一个数重新开始加）
所以第一种算法：使用贪心算法 一直加 一旦小于0就返回0 如果比记录的数要大 就更新最大的数 并且继续加着走

    第二种算法：动态规划
    
    什么叫动态规划：只针对数组本身 按照一定的规律走下去 并能得到结果
        所以 把数组每一个当前位 改变为在 当前位上的 目前最大子数组的和 所以每次遍历 就需要判断在前面的位置是否小于0 小于0的话就意味着 加它不如不加（加0） 否则就加上它 
        这样 更新后的数组 每一位代表的意思 就是当前位置下 的最大子数组的最大和 
        最后输出这里面的最大值即可（可以重新设置一个数 来在每次更新数组数字后 来判断是否更新这个数 （类似贪心））
