对于本题 首先能想到的是：递归
  但是从本题可以看到，简单的递归是很浪费时间的，比如对于本题而言，要双倍的递归
  
于是很自然的想着能不能节约一半的递归，所以相到开辟一个数组，来存放每次递归的的数，第二个递归直接从这里面取就行了
  所以：
      int ret[n+!]开辟一个数组，这里之所以是n+!是因为定义数组时定义n+1个，其内部是从0开始的
      ret[0]=0;ret[1]=1;初始化  
        for(int i=2;i<n+!;++i)这里i从2开始，因为数组要从2开始存放数据，到等于n结束
        ret[i]=re[i-1]+ret[i-2]这样。就能实现每次递归都从数组中取数了
        
  但是上述方法需要开辟一个数组空间。空间复杂度是On，那么就考虑能不能不开辟这个数组，只用一个数字进行交换，所以：
  
  int a=1;b=0;sum;定义a指n-1，b指n-2。并初始化,前面还要直接输出0和1的情况。然后从n=2开始走
  for(int i=2;i<n+!;++i)
    sum=a+b;算出当前和
    b=a;下一个n-2的位置的数字是当前n-1位置的数字
    a=sum;下一个n-1的位置的数字是当前和的数字
    
    最后返回sum即可
    这样就实现最快的运算，且节约空间
    
