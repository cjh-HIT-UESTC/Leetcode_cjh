这道题 不管用任何方式 核心思想就是：按部就班保存当前值  再保存在当前输入情况下的最小值  经典是使用两个栈实现  也可以用指针的形式 指针上保存这两个值

  通过本题 我进一步理解了指针 学会了如何定义指针结构体：
  struct Node    //在这里struct 和class 都可以
    {
        public:         //属性（一般用来设值）
            int val;
            Node* next;
            int min;
        public:
            Node(){}     //定义指针，但是这个指针内部什么都没有（也可以不写）
            Node(int x,Node* p,int min)////**************************这种定义方式 重要         利用this指针 实现当前指针被下一个指针所指  而不同于常规的当前指针指向下一个指针
            {
                this->val=x;
                this->next=p;
                this->min=min;
            }
    };
    
    定义空指针时：不需要用new 直接赋值即可： Node* p=nullptr;
    
    在函数中利用指针结构体内的函数：p=new Node(x,p,(p->min)<=x?(p->min):x);////实现下一个元素指向上一个元素
    ****************************需要注意的一点是：要用new 并且由于要反复调用 所以得注意这个指针的作用域*******************************
    ****************************如果指针不在外部声明，那么它的生命周期就只在当前{}内部，无法实现反复递归调用*********************************
    
    *************所以很重要的：要注意定义的数据的生命周期！！
