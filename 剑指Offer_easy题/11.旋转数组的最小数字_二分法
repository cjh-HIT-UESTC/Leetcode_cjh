首先 可以直接暴力，用第一个数去查找，这样时间复杂度为On

但是，由于像这类的查找问题明显可以使用二分法来做
  二分法：
  int low=0
  int high=n.size()-1先初始化左右边界
  
  while(low<high)  循环，条件是左边小于右边
    int mid=low+(hing-low)/2这样写的目的是为了防止加法溢出，在每次循环前更新中间值，所以中间值仅由左右边界确定
     if(中间值大于右边界)
        low=mid+1 更新左边界  加一是因为不再需要mid的那个，因为在右边必有需要的值
      else if(中间值小于右边界)
          high=mid 更新右边界  不加一是因为这里可能最佳答案就在右边界
       else
        high-- 与右边界相等的化，就把右边界--所以上面不减一也不怕进入死循环
        
        return low  最后输出左边界
        
        
        在本题中，首先要注意的是二分法的逻辑问题，然后是if else if else的问题，只能这样写，而不能三个if 因为这样会重复执行
       
