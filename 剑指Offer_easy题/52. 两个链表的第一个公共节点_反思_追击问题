首先理解本题题意：两个链表若有公共节点 是指指针指向同一段链表（与它的值没有关系）

所以，首先能想到最暴力的方法：依次两次循环去判断指针是否相同 如果找不到就返回nullptr  但这种方法明显太耗费时间

然后 想到追击问题：因为本题 链表的指针必然是一个位置一个位置的走 且目标是找到它们的指针相同的地方
    所以，可以把链表A看作长度：a+c   链表B长度：b+c   
    那么链表A只要补长度b   链表B只要补长度a    这样它们的长度就都是a+b+C了
    这样只要一开始就让它们从头开始走 这样必然会在公共节点处 相遇：链表A走完就去走链表B    链表B走完就去走链表A
    
  需要注意的是  循环条件是p1!=p2   那么为了能跳出循环 那么就需要能让两个指针能同时指向空指针  所以不能p1->next==nullptr就让p1=headb 
  而应该p1=p1==nullptr?headB:p1->next;  这样就能让p1指向一次空指针  
  这样 如果两条链表不相交 也能同时指向空指针 并跳出循环
