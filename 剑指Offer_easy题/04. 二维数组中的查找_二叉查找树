class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        //输入 二维数组向量（vector装的） Int 返回bool
        //首先 要在脑袋中模拟 查找这个数的最高效的方式：先比较最右边 找到大于这个数的位置 然后再比较最下面的数（但仔细一想，这样也不对，因为给的数字大小不定，不能每次从边界开始比）

        ////重新思考：目标是要找到这个数组的特殊之处
        //我考虑到了 对角线  可以发现这样一件事：如果我去找20 一旦在对角线上 找到了刚好大于和小于它的数的位置 那么 只需要去比较小的数一行的它的右边  大的数的左边
        //但我又突然想到 这tm不是个n*n矩阵！！！ 
        //    然后我又想到了：从矩阵的左下角开始（因为这里的数很特殊）
        //一旦左下角比这个数大，就往上走，直到找到比这个数小的地方，然后向右，直到碰到第一个比它大的数，然后再上，直到碰到比它大的数，就向左，直到碰到比它小的数，就向上，这样不断重复
        //一旦左下角比这个数小，就向右，直到比这个数大，再向上，直到碰到比它小的数，向右，直到比它大，向上，直到比它大，向左直到比它小，这样循环

        //在描述上述过程的时候，我感受到了一种规律，并且发现这样比较高效

//二维数组向量的行列：行数：matrix.size()  列数:matrix[0].size() 
        

        int hnum=matrix.size();//行数     需要注意 对于空矩阵 不能这样做
        ////对空矩阵
        if(hnum==0) return false;
        int lnum=matrix[0].size();//列数    需要注意 对于空矩阵 不能这样做matrix[0]  因为找不到
        if(lnum==0) return false;    //注意对于[[]],行数为1，列数为0
        int i=0;//0行开始
        int j=lnum-1;//最后一列开始
        

        //但是我发现以上算法说起来简单 但是实现起来复杂 因为首先分为两种情况 每种情况里又有4种走法 还不考虑一些特殊情况 所以要在这种规律性下重新考虑

        //因为对数组的控制 是由行列决定的 所以很自然的能想到 用双指针代表行列 
        //这个数组：对任何位置，左上角都小于等于它 右下角都大于等于它
        //因为对于算法，好的算法应该能包含特殊情况：所以可以考虑只有一行：那么必然要在这一行里二分查找到最合适的位置 对只有一列也同理
        ////现在扩展一下：在最开始使用了二分法找到了最合适的位置，比如对于20就找到了第1列第2行的位置，    不行哦不行

        //根据这种结构 可以看到对任意位置的数 左边的小于它 下面的大于它 所以可以从右上角来看 
        //一但目标小于当前数 就向左 否则向下 找到就返回 结束条件是无数满足这样循环(出界)
        
        while(0<=i && i<hnum && j<lnum && j>=0)////注意这里不能0<=i<hnum   ！！！！！！！！！！！！！！因为 0<=i先判断 返回1或0  然后再比较  所以会产生不正确！！！！！！
        {
            if(matrix[i][j] <target )
            {
                i++;
            }
            else if(matrix[i][j] > target)
            {
                j--;
            }
            else 
            {
                return true;
            }
        }
        return false;

    }
};
