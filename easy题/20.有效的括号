class Solution {
public:
    bool isValid(string s) {
        //考虑 输入为：字符串 输出为：bool类型
        //因为要比较字符串的每一个字符 所以一定会有取字符 所以考虑使用一个循环进行取字符

        //本题第一个关键：如何进行括号的匹配
        //我脑海中第一种想法：使用ascll码： （：40 ）：41 {：123 }:125  [:91 ]:93
        //所以可以（a==a+1 || a==a+2）
        //那么下面看怎么把字符变为Ascll码
        /*  实验
            输出41-40=1
        	string s = { "()" };
	        int a = s[1] - s[0];
	        cout << a;
            */     
        /*     
        if(s[1]-s[0]==1)            return true;
        else 
        return false;
        */
        //到此 就解决了括号的匹配问题
        
        //本题第二个关键：括号的开闭顺序问题
        //假如设想：从左往右循环读取 拿到第一个括号（明显这里不能是反括号）后，往后走，去看是否有同一种反括号
        //如果没找到同一种反括号，直接false，如果找到了：
        //就要看这两个括号之间，括号是否对齐匹配了
        //我的头脑中第一个想法是：记录从第一个括号i到第一个反括号j的序号差，然后再从i+1出发直到j-1
        //如果在这里面找到了就更新i=i+1，j=找到的位置,  到这里我发现了问题
        //如 ([{()}}])  这里多了一个}  然而不好处理 并且第一个反括号）会找到里面的那个 所以从左往右不行

        //我思前想后，找特殊的有一定规律的地方，我发现：如果先找正括号，那么去找和它匹配的反括号很难
        //因为反括号并不一定和它位置匹配，比如：（【（）】），第一个（和第一个）位置并不匹配
        //所以 我想到了：
        //为什么不先找反括号呢？ 所以我想出了下面的算法：
        //从左往右，先找到第一个反括号（可以利用ascll码）（如果它在第一个位置直接false），
        //然后与它左边的符号做对比，如果不匹配那么直接false，如果匹配，就删除这两个字符
        //然后再往右找第一个反括号，重复上述算法

        //在上述算法中，我认为唯一的问题就是如何删除字符
        //以下做删除字符串里字符的操作实验"({{([])}})"
        /*
            	string s = { "({{([])}})" };
	            s.erase(0, 1);//erase (iterator first, iterator last);
                              //first和last分别表示范围的起点和终点
	            cout << s;
                //输出了{{([])}})，成功删除了起点为0到终点为1的字符
        */
        //到此 就解决了删除字符的问题，开始写算法：

        //如果为奇数个字符，直接判false
        if(s.size()%2 !=0)
        {
            return false;
        }
        //for(int i=0;i<s.size();i++)//用循环去取字符串里的每个字符       之前写的for循环，i不能改变
        int i=0;
        for(;i<s.size();i++)//用循环去取字符串里的每个字符           因为s.size()在不断变小
        {
            //第一个问题：怎么找到反括号，我想到的是：利用ASCLL码或者直接字符匹配（因为只有三种，比较少）
            if(s[i]==')' || s[i]==']' || s[i]=='}')//找到了第一个反括号
            {
                if(i==0)//第一个字符为反括号的情况
                {
                    return false;
                }
                //判断左边的是不是匹配的括号i-1
                if(s[i]-s[i-1]==1 || s[i]-s[i-1]==2)//匹配
                {
                    s.erase(i-1,2);//删除这两个字符,需要注意的是，为i-1为起始位置，删除2个
//************************erase函数的用法一开始我用错了！！！！！！！！！！！！！*******************
                    i=0;//i置为0，从最左边开始**************这里为关键，重新从左边开始**************
                }
                else 
                {
                    return false;//如果不匹配，直接返回false**************是这里的问题************
                }
            }
            //else if(i==s.size()-1 && !s.empty())//找不到反括号了***s.size()-1有问题***但不是这里的问题
            //s.size()-1，当s为空时，减出来有问题,需要用int a=s.size()-1
            else if((i==s.size()-1) && (!s.empty()))
            {
                //i已经找到字符串最后位置了，又不为空
                //if(i==s.size()-1 && !s.empty())               
                    return false;
            }
            //第二个问题 怎么判断成功？ 很自然明显的 能想到当s为空时 就说明成功了  那么判空可以用empty
            //if(s.empty()) 
            //{
            //    return true;
            //}
            //最后 我还发现了一个问题 那就是最后一个字符为正括号怎么办？比如：（）（
            //在这里 我又想到了：当字符数量为奇数的话，使用删除会导致最后i-1报错（因为最后只剩一个，找不到了）
            //但很好解决，那就是如果字符数为奇数，直接输出false
            //现在继续讨论刚刚的问题 改进一下 比如：（（）（
            //很自然的 想到 如果在剩下的字符里 如果不为空 又找不到反括号了 那么就false 所以到此就解决了   

            //忽然 我又发现了一个问题 就是 因为我用了删除操作 会导致i的循环下标出错，现在考虑如何解决
            //很快的 我想到了 因为用的是删除操作 那么可以让i保持每次循环都从0开始，循环改变的是S的长度
            //开始，我想在for循环处入手，发现很难改，除非把它写成函数，然后自己调用自己
            //最后，发现，在删除操作后，i置0就行了。重新从左边开始
            
        }
        //for循环退出的原因 只能是由于s.size()为0了 即为空了
        return true;
    }
};
