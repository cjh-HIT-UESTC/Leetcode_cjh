/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        //注意本题 返回的是指针 接收的对象也是指针（结构体指针）
        //考察的是 1、链表 2、结构体指针 3、排序
        
        //1、链表 先回想什么是链表： 首先回想线性表：按顺序存储的数组，但由于必须连续所以不方便，于是利用头或者尾指针，构成链表
        //链表可以随便放在哪里，然后通过指针相邻，这样就很方便，缺点是需要多耗费内存去存储指针   所以链表的关键在于：指针

        //2、结构体指针：首先回想什么是指针：指针就是用来指向数据的地址空间的一个数据，可以通过解引用来获取这个地址空间里的值（&或者->）
        //          指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。
        //结构体指针：就是用来描述结构体的，结构体和普通变量有一个很重要的区别：那就是结构体的名字就是一个地址，所以可以直接利用名字解引用

        //3、排序 排序中最经典的方法就是：冒泡排序，就是依次比较2个数，小的在前大的在后，比较完之后再从头开始（这时不需要比较最后两位）
        //这样一直下去，最终只需要比较前两位，当比较完之后，算法就结束了

        //但本题有一个特殊的点：那就是全部都是升序链表 所以需要考虑怎么排序更简单
        //我首先想到的排序方法是：用L2中的第一个元素先去在L1中挨个比较，当找到比L1中元素小或者相等的元素时，就链接在这个元素后面
        //然后L2中的下一个元素 再从它的上一个元素的位置重新在L1中查找，直到L2中所有元素结束
        //针对上述我提出的算法 我突然想到的一点是：为了提高算法速度，可以不指定从L2去找L1，而是先比较他们的长度，用长度小的去找长度大的

        //然后现在要考虑特殊情况：1、当都为空时，直接返回空。 2、当有一个为空时，返回另一个不为空的链表

        //在本题要开始做之前，我遇到的不懂的问题：1、如何用这个结构体得到它里面数据的个数？2、如何对里面的数据进行循环？
        //                                      3、如何利用它的指针进行拼接？4、如何返回一个结构体指针？

        //第1个问题：  
        /*
        //打印函数
                 void List::print()
                {
                     for(Node * p = head->next;p;p=p->next){
                         cout << p->data << endl;
                     }
                }
        */
        //输出结果为l1，说明l1为头指针
        /*if(l1 != nullptr)
        {
            return l1;
        }
        else
            return l2;*/
        
        //第1个问题 得到里面的数据个数：
        //输出了【】，说明l1=l1->next是对的，成功计算了个数i=3，并且返回的l1为空，说明从指针指向最后那里返回的
        /*
        int i=0;
        while(l1 != nullptr)
        {
            i++;
            l1=l1->next;
        }
        if(i==3)
        return l1;
        else return l2;
        */     
        //第一个问题就能解决了

        //第2个问题：
        //进行循环：很简单了，利用指针不为空就可以

        //第3个问题：
        //把当前指针赋给需要拼接的指针
        //l1=l2;
        //return l1;//输出了l2的值，说明这里只是简单赋值了
        //l1->next=l2->next;//输出了1,3,4说明把l1头指针和l2后两个链接起来了
        //return l1;//l1->next=l2输出了【1,1,3,4】和我想的一样，在l1的头指针后面把l2的头指针链接上了，导致在l1的第一个元素后面跟上了全部l2
        /*
        (l1->next)->next=l2;//输出[1,2,7,8,9]
        return l1;
        */

        /*
        ListNode *p;
        p=l1;
        for(int i=0;i<1;i++)
        {
            p=p->next;
        }
        //以上。p指向l1的第二个元素
        ListNode *q;
        q=l2;
        for(int i=0;i<2;i++)
        {
            q=q->next;
        }
        //以上，q指向l2的第三格元素

        l1->next=l2;
        q->next=p;
        return l1;//返回了:1,1,3,4,2,4
        */
        //以上，就能实现拼接，   其关键所在：就是理解指针指的是位置，next指的是当前元素的尾巴

        //第4个问题
        //返回结构体指针就很容易了：返回那个数组的 头地址 就行了


        //下面开始解决本题：
        //先解决特殊情况：
        //两个都为空    （判空，用头地址是不是nullptr）
        //if(l1==nullptr && l2 == nullptr)   return l1;
        //有一个为空，另一个不为空
        //if(l1==nullptr && l2 != nullptr)    return l2;
        //if(l1!=nullptr && l2 == nullptr)    return l1;


/*
        //以下为普通情况
        //先查找l1里数据的个数
        ListNode* count_l1;
        count_l1=l1;//作为一个新的l1副本
        int i_l1=0;//存放l1里面数据的个数
        while(count_l1 != nullptr)
        {
            count_l1=count_l1->next;
            i_l1++;
        }
        //查找l2里数据的个数
        ListNode* count_l2;
        count_l2=l2;//作为一个新的l2副本
        int i_l2=0;//存放l1里面数据的个数
        while(count_l2 != nullptr)
        {
            count_l2=count_l2->next;
            i_l2++;
        }

        //判断长度，用少的找多的
        if(i_l1<=i_l2)
        {
            //开始遍历
            for(int i=0;i<i_l1;i++)
            {
                for(int j=0;j<i_l2;i++)
                {
                    if(l1->val <=l2->val)
                    {
                        //****************************太复杂了，重新思考******************************
                    }
                }
            }
        }
*/
/*
        ListNode* p;
        ListNode* q;
        ListNode* head;
        head=p;
        while(l1 !=nullptr)
        {
            q=l2;
            
            if(l1->val <= q->val)
            {
                p->next=l1;
                
                p=p->next;
                p->next=q;
                p=p->next;
                l1=l1->next;
            }
            else
            {
                q=q->next;
            }
        }
        return head;
*/





        //重新写      看了答案之后
        //想法：对于l1和l2，看成两个栈，每次拿栈顶出来比较，如果l1的小于等于l2的就把l1的栈顶pop掉（这里可以用指针移位来完成
        //然后再进行下一次比较，拿出去的元素放到一个新的栈中，依次按从小到大放进去，直到l1或者l2的栈为空，这时把剩下那个不为空的直接拼接

        //所以要定义一个新的栈（容器）这个容器是一个指针结构体
        ListNode* p=new ListNode(-1);//返回[-1]
        //**********************这里必须初始化，因为不初始化的话，就相当于创建的新的栈是不存在的**************************

        //因为最后要输出这个结构体，所以需要用一个指针指向这个结构体的头部
        ListNode* head;
        head=p;//head记录这个新的栈

        //循环的条件是l1或l2不为空指针
        while(l1 != nullptr && l2 != nullptr)
        {
            if(l1->val <= l2->val)
            {
                //如果l1的栈顶小于等于l2，则把l1的栈顶放进p中
                p->next = l1;
                //然后l1 的指针就要移动
                l1 = l1->next;
            }
            else
            {
                //l2的比较小，就同上操作
                p->next = l2;
                //然后l2 的指针就要移动
                l2 = l2->next;
            }
            p = p->next;//不管是l1还是l2，p的指针都要往前移动
        }

        //拼接剩下的l1或者l2
        p->next = l1 == nullptr ? l2 : l1;//三目运算符，意思是,l1等于空指针吗，等于返回l2否则返回l1


        return head->next;//这里之所以要返回head的next，是因为head是从-1开始的（初始化位置），next就从真实位置开始了

    }
};
