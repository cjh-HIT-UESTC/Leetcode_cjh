class Solution {
public:
    string countAndSay(int n) {
        //对于本题 可以很暴力的：把1--30所描述的所有字符串写出来，用哈希表快速查找，但这种方法很憨
        //因为输入仅为数字n，输出为结果字符串，所以要考虑一下特殊的地方
        //这道题我在模拟算法过程的时候，感受到了： 一点递归的味道   所以我想这道题是不是该使用递归的方式，自己调用自己

        //因为想到了递归，而且本题关键的一点：第n个的输出要看第n-1个输出（且它返回的是string），并且每一次必返回两个字符：个数与数字
        //所以以下写 最普通的情况（抛弃一些特殊情况，如：n=1，等）

////在本题我学会了一个重要的知识点：
//对于string类型 如果str[1]是数字如：1  那么int a = str[1]-'0'就变为了数字1
//对于char类型 如果j是数字 那么 chr = j+'0' 就转为；额char类型
//对于要把int 转为 string类型 可以用函数：to_string(int)

/*
        //现在添加初始情况
        if(n==1)
        {
            return "1";
        }


        string ss = countAndSay(n-1);//上一个数字返回的字符串
        int j=1;//用来记录每个数字重复出现的次数
        //vector<string>s1;//用一个string容器用来存放最后输出的数字字符串
        string ss1;
        char s1[100];
        s1[0]='1';
        s1[1]='1';
        int ii=0;//表示在新的字符串中的位置
        int i=0;
        for(i;i<ss.size()-1;i++)
        {
            if(ss[i] == ss[i+1])
            {
                j++;
            }
            if(ss[i] != ss[i+1])
            {
                s1[ii]=j+'0';//第ii个位置存放个数
                s1[ii+1]=ss[i];///第ii+1个位置存放数值
                ii=ii+2;//递增加22
                j=1;//清零  表示只有一个数
            }
        }
        //这是对于最后位置的
        s1[ii]=j+'0';//第ii个位置存放个数
        s1[ii+1]=ss[i];///第ii+1个位置存放数值
          
        ss1=s1;
        return ss1.substr(0,ii+2);

        ////////////////////////以上算法正确，但是超时了，我想：这是由于越到后面，递归的次数会变多，使得超时了
        //但是当我看了答案后 发现并不是递归的问题 而应该是我对字符串的操作不熟，利用了char类型，并调用了substr函数导致的
        //因此对字符串的操作进行更改
*/
    

     //现在添加初始情况
        if(n==1)
        {
            return "1";
        }


        string ss = countAndSay(n-1);//上一个数字返回的字符串
        int j=1;//用来记录每个数字重复出现的次数
        //vector<string>s1;//用一个string容器用来存放最后输出的数字字符串
        string ss1="";//******************************************************利用字符串的拼接
       // char s1[100];
        //s1[0]='1';
        //s1[1]='1';
        int ii=0;//表示在新的字符串中的位置
        int i=0;
        for(i;i<ss.size()-1;i++)
        {
            if(ss[i] == ss[i+1])
            {
                j++;
            }
            if(ss[i] != ss[i+1])
            {
                ss1+= to_string(j);//第ii个位置存放个数
                ss1+= ss[i];///第ii+1个位置存放数值
                ii=ii+2;//递增加22
                j=1;//清零  表示只有一个数
            }
        }
        //这是对于最后位置的
        ss1+= to_string(j);//第ii个位置存放个数
        ss1+= ss[i];///第ii+1个位置存放数值
          
        return ss1;

//以上代码运行成功了    说明果然是在用char类型存放数据 再转换为string 的过程太慢了  本道题很关键的点有两个点：
                //1、字符串拼接的使用（利用这个就可以巧妙的避免利用下标的拼接）
                //2、函数to_string（int）的使用：把int类型转换为string类型




    }
};
