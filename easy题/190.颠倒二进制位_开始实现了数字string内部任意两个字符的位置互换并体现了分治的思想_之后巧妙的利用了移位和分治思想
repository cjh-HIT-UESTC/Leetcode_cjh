class Solution {
public:
/*
//首先定义一个交换函数，输入为三个参数（n，左边的索引，右边的索引），输出为换位之后的n
        string reverse(string n,int L,int R) 
        {
           //// n[L]=n[L]-'0'+n[R]-'0';
            //n[R]=n[L]-n[R];
            //n[L]=n[L]-n[R];
    //实现了在string中 换两个数字的位置
            char a=n[R];
            char b=n[L];

            int a1, b1;
	        a1 = a + b-'0'-'0';//5
	        b1 = a1 - b+'0';//3
	
	        a1 = a1- b1;//2
	        char s2 = a1 + '0';
	        char s1 = b1 + '0';
	        n[L] = s1;
	        n[R] = s2;

            return n;
        };

    uint32_t reverseBits(uint32_t n) {
        //输入为 长度32 的二进制 字符串
        //我第一反应是:分治：分为2部分（16++16），两个部分都颠倒，然后再拼接

        //然后根据这个思想，我想到了：这道题翻转其实可以看作从中间两个位开始，L和R同时向两边走，L和R处的数字换
        //那么用到了：a=a+b;b=a-b;a=a-b;
        //调用这个函数，对于32位的数仅需要循环16次
        string n1=to_string(n);
        for(int i=0,j=0;i<16;i++)
        {
            n1=reverse(n1,i,31-i);
        }
       
        //int  n2=atoi(n1.c_str());
        
        //二进制转十进制
        unsigned int sum=0;
        for(int i=0;i<31;i++)
        {
            sum=sum*2+n1[i]-'0';
        }

        return sum;
}
*/
        ////////////上述操作是在n位string类型下进行的 但是uint32_t并不是string类型，不能用索引访问,我解决了
        //////但是发生了溢出，我并不知道在哪出现了问题，但是我已经达到了我的目标，实现了写一个函数进行字符串内部的互换

        //现在重新做这道题
    uint32_t reverseBits(uint32_t n) 
    {
        //本题我认为对我影响最大的地方在于：我不知道输入的是字符串还是数字
        //我查了uint32_t 是无符号的int 那么我在想它怎么存放那32个数的呢？而且 题目说它是字符串 所以很迷
       //// return n;//输出了：           0 (00000000000000000000000000000000)
        //return n.size();//输出了错误：他是int不能size    所以我能肯定 它不是字符串
        //那么我就把它看作int，存放了二进制数
        
        //那么很轻松的，能想到，把它每次右移移位，然后转为十进制
       
        //return ((1<<2 )& n )<<27;//           4 (00000000000000000000000000000100)
        uint32_t sum=0;
        for(int i=0;i<16;i++)
        {
            //sum+=(((1<<i) & n) <<(31-i));
            sum+=(((1<<(i+16)) & n)>>(2*i+1));//这能够实现输出与n相同，说明印证了我的想法，每次都是32位的数直接对应相加
            sum+=((1<<i) & n) <<(31-2*i);
        }

        return sum;









    }
};
