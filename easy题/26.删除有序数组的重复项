class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
//想法一：
/*

        //首先本题的题意是：返回数组的新长度 并把nums前len个按顺序排列即可后面可以有元素
        //于是我根据 原地删除 立刻想到了 把数字和后面的数字换位
        //进一步 我想到了冒泡排序，但需要对它作出改进：
        //第一个数依次与后面的数作比较 一旦它大于等于（注意这里的等于）后面的数 就让它们换位置 
        //并且 下一次重复上述过程是从第二个位置开始（重要，理解一下）
        //然后关于长度：就一旦第一次有小于等于 就标记位++1

        //因为下面的代码不能处理输入为空的情况，所以把特殊情况拿出来：输入为空，或者输入仅一个数字
        if(nums.size()==0 )
        {
            return 0;
        }
        if(nums.size()==1 )
        {
            return 1;
        }
        //如果输入的数组中每个元素都相同
        if(nums[0] == nums[nums.size()-1])
        {
            return 1;
        }

        int len=0;//标记长度
        for(int i=0;i<nums.size()-1-len;)//这里之所以是-1-len，首先是因为有i+1的出现，然后-len是因为
        {                                   //一旦有一个换到这后面了，那么i就没有必要比到最后那个位置了，结束位置就往前提前
    //这里有问题：每次循环之后就把i+1的话会导致当有111这样三个连着的时候，被跳过中间都
    //所以每次并不+1，而是还在当前位置上判断，当不相等后，再+1
            //开始循环
            if(nums[i]==nums[i+1])
            {
                ////    len++;///把len换了位置！！！！！！！！！！！！！！！！！！
                int j=i;
                //开始换位置，把i+1的数换到最后面
                for(j ;j<nums.size()-len-1;j++)//因为不需要每次都换到最最后面，只需要换到len触及不到的地方即可，这样能更快
                {
                    //这里j<nums.size()-i，不能-1，会导致1223，这种换不了位，因为数组为2个起，所以不用-1****还是要-1
                    //换不了位是由于没有在当前位判断就直接+1导致的
                    //这里涉及到，不添加第三个数，来交换两个数：很简单：用加减法即可
                    //a=a+b;
                    //b=a-b;
                    //a=a-b;
                    nums[j]  = nums[j]+nums[j+1];
                    nums[j+1]= nums[j]-nums[j+1];
                    nums[j]  = nums[j]-nums[j+1];
                }
                len++;///把len换了位置！！！！！！！！！！！！！！！！！！
            }
            else//多加了这个判断，在当前位上进行判断
            {
                i++;
            }
            //以上当输入1111时，会进入死循环
        }
        return nums.size()-len;
*/
//以上算法正确，但是很费时间，超出了时间限制

//以下重新思考，让算法快速
        //我想到的，把数组看作队列，每次比较前2个，如果相同就把队前pop放到队后面
        //这样就有一个问题：因为上述的算法基本思想也是这样，但我用的是冒泡思想，导致了超时，那么我想到了：用指针
        //因为对于一个数组而言，它的名字就是数组的头指针(所以这里的指针指的是 数组下标)

        //看了一眼答案，有了这样的想法：从头开始去找（不循环），当找到nums【i】和nums【i+1】不相等时，就把一个标记位j++
        //然后把这里的值赋值给nums[j],（实际思想就是，一旦找到不相同的值，就按顺序赋值给数组）
        int j=1;//标记位,从第二个数开始

        //依旧 特殊情况
        if(nums.size()==0 )
        {
            return 0;
        }


        for(int i=0;i<nums.size()-1;i++)//开始递增
        {
            if(nums[i] !=nums[i+1])
            {
                nums[j] = nums[i+1];
                j++;
            }   
        }
        return j;
    }
};
