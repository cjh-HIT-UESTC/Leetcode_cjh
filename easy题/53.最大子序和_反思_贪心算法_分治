首先对于本题 我没想出来 我想的办法到最后被我发现是错误的，因为没有我说的那个停止位
真正的停止应该是当前的数字与之前全部的数字相加小于0了，才停止返回0，停止

对于本道题我想我第一个收获 肯定是贪心算法了：

这道题的贪心算法，其实用了两条线（类似），第一条线毫无疑问的就是贪心线，表示当前的最优值
      第二条线，就是每个数字和之前的数字相加，只要加起来大于等于0，就说明我还能继续贪心下去
      （因为只要前面不小于0，那么只要后面出现了一个足够大的数，那么前面的所有数字就又有用了，如果没有这个足够大的数，也没关系，反正已经记录了最优值）
      但是在这个贪心的过程中，必须注意到，一旦前面的值相加小于0了，那么就不能贪心了：不管之后的数字多么大，之前的那些数都不需要了
      于是直接判断这个值有没有最优值大，有的话更新最优值，没有的话，就从这个数这里重新开始贪心（所以要返回0）
      而这个返回值0对于全负数来说，也很有用，它能表示每次最优值和当前值相比，从而取出最大的那个值。
      
      关键就在于理解这道题的核心：只要不为0就能继续贪心，一旦小于0就不能继续贪心，要重新开始贪心，用返回0表示当前值并与最优值比较。
      
      关于 分治 和动态规格 我现在看不大懂也不想看，以后再说吧
