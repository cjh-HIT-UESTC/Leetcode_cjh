本题的思路很简单 就是模拟二进制 
但本题有一些坑：两个长度不同，有短的和长的，最后输出的要以长的位依据，所以首先得判断谁长谁短，
然后设计一个进位标志，然后遍历每一位，并依次设置进位标志，根据进位标志再重新设置（这里要注意三个地方）
最开始进入循环处，进位为0
出最短串处，要多加一次循环判断长串
长串判断完处，如果还有进位，那么要用函数insert在最前面加一位   l.insert(l.begin(),'1');  注意这里为对字符串的insert


先用reverse(a.begin(), a.end()); 反转字符串   
之所以要反转字符串是为了方便使用push_back函数
push_back函数，在vector类中作用为在vector尾部加入一个数据。
string中的push_back函数，作用是字符串之后插入一个字符。


carry += i < a.size() ? (a.at(i) == '1') : 0;
本题这种写法很巧妙，利用了逻辑值0和1，carry为Int
 ans.push_back((carry % 2) ? '1' : '0');
 再这样把int类型转为了char类型，这种写法非常的巧妙
 
 carry /= 2;
 并这样表示了是否进位
