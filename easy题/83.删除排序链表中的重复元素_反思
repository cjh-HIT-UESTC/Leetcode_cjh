本题与21题类似，目标都是升序排列的链表，并且都是对指针，结构体指针就行操作
在本题中，我思考采用了栈的方式，创建一个新的链表栈（类似），然后对原链表两个两个进行比较，如果相同则出栈并舍弃，否则就入栈

当然，也可以像答案一样，不用一个新的链表栈，直接来判断进行重新连接
总而言之 这道题的算法是很简单的（只要理解了指针，结构体指针）

本题关键： ListNode* p_label= new ListNode(-1);  要用new 给出一个新的空间，并初始化
      head->next->val  ：结构体指针的使用
      A->next = p_label->next;最后关于指针的位置，要思考清楚
      
      
      答案：
       ListNode* cur = head;                相当于把head当作头指针，然后用cur指针去操作（一开始，两个指针指向同一个实际的物理地址空间，类似于虚拟内存）
      while (cur->next) {
            if (cur->val == cur->next->val) {
                cur->next = cur->next->next;  这里直接去进行链表重连
            }
            else {
                cur = cur->next;           这里就往后接
            }
        }
    
    
    注意要在一开始定义一个头指针，方便之后输出整体链表
