本道题我觉得很重要  因为他帮助我很好的理解了指针 理解了链表 理解了结构体指针
首先对于本道题：
我首先想出来了一种解决算法：
  1、首先输出特殊情况，有为空的情况
  2、然后，先判断两个数组谁的长度更小，用小的数组里的数去一个一个和另一个数组里的数据作比较（这样就比单纯的用l1比l2要更快）
      一旦发现比比较的数字小就放在这个数字的左边（因为他们都是升序数组），然后下一次起始的位置就由这里开始，直到这个数组里的数字为空
    
    但是，这个算法实现起来很难：因为需要把单个数据拼接进链表里面（我没想出怎么从一个链表里依次取一个数据然后再拼接到另一个链表里去的方法）
    这个循环实现起来非常的困难
 
 然后我看了一眼答案，立刻懂得了在我想出的方法上做一点改进即可：那就是不要用一个数组的一个数据去和一整个数组作比较
    而是应该，用每个数组的一个元素来比较（这样就从1对多变成了一对一）
    更进一步的，我们可以把l1和l2看做两个栈，每次比较栈顶，把小的那个拿出来，那么很自然的，就需要另外一个栈来存放，直到有为空的出现
    最后，当一个数组为空后，再把另一个剩下的拼接进去就行了（这样的话就可以自动完成特殊为空的情况了）
    
 在本道题编程过程中需要注意的点有：
 1、定义那个新的栈的时候，我们不能只定义一个指针而不初始化，即：ListNode* p：
            这样一来就像只告诉了计算机，我有一个栈（但我实际上并没有），计算机内部有没有这个栈，所以只是虚有其表（我想可以理解为浅拷贝）
      应该把它初始化： ListNode* p=new ListNode(-1);//返回[-1]  这里根据初始化函数具体来
            需要注意的是，这样一来返回的就是一个初始化为：一个值为-1，指针指向它的指针
            还要注意的是：这里的new不能省略  因为就像之前说的那样，new了，计算机才会给它真正的创造出空间，用来存放pop出来的数据
2、因为这个栈的指针在后续会不断地变化，为了在最后能输出整个栈，所以我们需要保持这个栈的栈顶的指针
    所以才需要新定义一个head，再把栈名赋给它，需要注意的是：在程序最后返回时，要返回head->next，因为head指向的是初始化的那个-1
3、最后需要理解的就是：指针的运动，指针只是指向这个链表的一个标记，所以一旦一个栈的栈顶pop了，那么就要移动指针到下一个地方
    如：l1=l1->next
    最后不管是l1还是l2pop，新的栈p都要移动：p=p->next
4、三目运算符的运用：
      p->next = l1 == nullptr ? l2 : l1;//三目运算符，意思是,l1等于空指针吗，等于返回l2否则返回l1
      
      
 在本道题中，我深入理解了指针，结构体指针，定义一个新的结构体指针需要初始化给它具体空间。头指针用于输出整个数组
          指针如何移动，如何对结构体内部的元素进行操作，三目运算符

 
