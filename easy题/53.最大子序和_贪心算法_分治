class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //本题的输入为 int容器数组 输出为 其和 最大和连续子数组：就是和最大的连续子数组hh
        //很直接的 我又想到了遍历 但显然 很费时间（因为要窗口为1到窗口为最大 这样去滑动）
        //首先 很自然的 当输入数组为一个数字时 直接返回
         
        //那么对于本题：需要去发现一些特殊的地方：最大和的连续子数组两边必为负数
        //所以我想到了：去找每两个负数之间的数组之和（先不考虑边界没有负数的情况）
        //于是我想到了一种算法：定义两个新的数A和B，从第一个数字开始对整个数组遍历（i），如果i处为负，用A与B做比，如果A大于B，A赋值给B
        //A清零，否则继续，如果I处为正（也可为0），就用A加上当前值，i继续走，当为负重复上述（A清零），当为正，继续，直到遍历结束，输出B
        //对于上述算法有一些特殊情况：若全为负数怎么办：显然该输出最大的那个负数
        //于是改进算法：
        /*
        1、定义两个数A,B=第一个数，如果大于等于0，进入正式算法；如果小于0：i从第二个数开始遍历
        2、如果i处小于0并且比A要大，A等于当前数，如果i处小于0并且小于A，A不变，如果i处大于等于0，A=当前数
        3、一旦A大于等于0，B=A；就继续遍历，A加上当前数如果小于B（遇到负数），B不变，A=0；
        4、如果大于等于0，就B==A=A加当前数；继续直到结束
        */

/*
        //开始写算法
        int A=nums[0];//把数组第一个数组给A和B
        int B=nums[0];
        int lable=-1;

        for(int i=1;i<nums.size();i++)//从第二个数字开始遍历
        {
            /*
            if(A<0)//如果当前出现的还是只有负数
            {
                if(nums[i]>A && nums[i]<0 )//当前数字为负数，并且比A大
                {
                    A=nums[i];//依旧为负数，给A
                    B=A;//B备份A
                }
                else if(nums[i]>=0)//当前数字为非负数
                {
                    A=nums[i];//为非负数了，记录这个非负数，并且可以跳出这一个if语句了
                    ////B=A;//备份
                }
                
            }
            else//找到了第一个非负数了，现在一直运行在这里面
            {    
                if(nums[i]>=0)//当前数大于等于0
                {
                    A+=nums[i];//加上当前值
                    //B=A;//备份
                }

                else//找到了负数，现在要判断大小，第一次的时候A==B
                {
                    lable=1;//说明在后面至少找到过一次负数
                    if(A>B)//当前A大于B
                    {
                        B=A;
                        A=0;
                    }
                    else
                    {
                      A=0;
                    }
                }

*/
/*
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if(i<nums.size()-1)
                {
                    if(nums[i]<0 && nums[i+1]<(-nums[i]) && -nums[i]>nums[i-1])
                    {
                        lable=1;//说明在后面至少找到过一次负数
                        if(A>B)//当前A大于B
                        {
                            B=A;
                            A=0;
                        }
                        else
                        {
                        A=0;
                        }//所以要多加一个判断，看能不能i+1
                    }   
                    else
                    {
                        A+=nums[i];//加上当前值
                    //B=A;//备份

                    }
                }
                else
                {
                    if(nums[i]>=0)//当前数大于等于0
                    {
                    A+=nums[i];//加上当前值
                    //B=A;//备份
                    }

                    else//找到了负数，现在要判断大小，第一次的时候A==B
                    {
                        lable=1;//说明在后面至少找到过一次负数
                        if(A>B)//当前A大于B
                        {
                            B=A;
                            A=0;
                        }
                        else
                        {
                        A=0;
                        }
                    }

                }
                


            }
         
        if(B>A) return B;
        else return A;

*/
/////////////上述算法确实能实现我的22想法，但是！！！！我忽略了一点，在最大和的连续子数组内也可以有负数！！！！！！！！！
    
    //我思考了一下，发现上述算法的开始条件没问题：从找到第一个正数开始
    //但是，结束条件不是碰到负数，而是应该：碰到了负数并且它的下一位小于它的绝对值
    //           并且这个负数的绝对值不能大于前面的值
    //所以需要修改上述算法的结束条件


    //上述算法已经被我搞得很复杂了 现在重新梳理
    //首先，算法开始的条件依旧为找到第一个正数，然后当找到了一个负数，这个负数的绝对值不能大于前一个数，否则更改起始位，等下一个正数
    //对结束位：找到了一个负数，并且它的绝对值大于下一位

    //下面是我对我想的算法的描述：
    /*
    1、定义A和B等于数组的第一个数，开始遍历，去找第一个正数，如果没找到就一直下去直到循环结束，
        如果找到了，就跳出这段条件语句,A和B都等于这个正数
    2、下一个数如果为负数的话，就比较这个负数的绝对值，如果绝对值大于当前数，就继续找下一个正数，没找到就返回这个正数，复杂太复杂了！！！
    
    
    换思路：如果能找到：那么必然是从 正数开始，且它一定大于它右边的绝对值，结束，一定是在负数处结束，且它的绝对值一定大于右边
    整理一下思路：
    1、开始处
            1、必定从正数开始，且它一定大于它右边的绝对值（不考虑全为负）2、要么就是正数在最后一位
    2、结束位
            1、负数处结束，且它的绝对值一定大于右边 2、负数为最后一位 3、没有找到负数，直接结束
    3、全为负
            找最大
    所以我又想到这样：采用双指针（双循环），第一个指针去找开始位，第二个指针去找结束位
    这样太复杂了哇！！！！

    */

    //我上面的题意理解全错了！！！！！！5555555555因为不管前面怎么样，只要它大于0，一旦后面出现一个够大的数，那么前面的我全都要

    ////看了评论区，看到了贪心算法，然后，我悟了
    /*
    对于这个数组，用两个值A和B，A用来记录每个数字与之前全部的数相加的结果：
    如果它大于等于0，那么它就还有希望，可以去期望后面有一个够大的数，直到它小于00了，那么他就没希望了，就返回0从0开始
    对于B，用来记录当前的最优值，一旦A比B大，就把A给B，所以它是那颗贪心
    然后A和B一开始就必须等于数组的第一个值，这很好理解，因为它们需要初始化，而且不管怎么样，返回的必是数组里的数
    对于一直找负数的情况，那么就要让A在加上当前值之前返回00，这样当A加上当前值后，就代表那一个负数了，再与最优值比较

    1、a=b=nums[0]
    2、for(循环)
    3、if(a<0) a=0
    4、a+=nums[i]
    5、b=b>a?b:a
    6、return b
    */

    int a=nums[0];
    int b=a;
    for(int i =1;i<nums.size(); i++)
    {
        if(a<0) a=0;
        a+=nums[i];
        b=b>a?b:a;
    }
    return b;
    }
};
