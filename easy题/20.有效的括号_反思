首先 本题处理的对象是字符串 输出的是bool类型 那么必然需要一个循环来取字符串中的每个字符  当取出字符后继续考虑：
第一个问题：如何进行括号的匹配
  显然，有两种方法：1、利用if（s[i]==‘)’）等直接匹配
                  2、利用ASCLL码   （：40 ）：41 {：123 }:125  [:91 ]:93
  显然，利用ASCLL码能完成的事比直接匹配要多（因为可以做数值运算）
  那么去看这些是否匹配可以这样写：
  if(s[i]-s[i-1]==1 || s[i]-s[i-1]==2)这样一来就可以完成括号的匹配了
第二个问题：怎样去找这些符号
  那么显然的，我们要先去讨论一些特殊的问题：
  1、当首字符为反括号时，直接false
  2、当字符数量为奇数时，直接false
  
 现在为了思考怎么找这些符号：
 1、自然的，首先想到从左往右寻找：
      那么寻找就分为两种：
          1、先找正括号
          2、先找反括号
    下面讨论第一种情况：先找正括号：找到第一个符号（假如为正括号），然后往后去找和它匹配的，发现很难，因为会出现多种情况
          如：（【（）】），找到的第一个）和第一个（并不匹配   短暂思考一会，可以容易判断出这个方法不行
    下面讨论第二种情况：先找反括号（重点）：
        首先从左往右，找到第一个反括号（这里，首字符肯定不是反括号），找到第一个反括号后，
        再往右返回一个字符，这时：
              这个字符如果和它不匹配，那么直接false
              如果这个字符匹配，那么删除这两个字符（可以使用erase()函数，这里要注意它的用法）
              删除之后，再重复上述步骤（从最左端开始，因为会有这样的情况：【】（）{}），需要注意的是：这里字符串的长度size()已经改变了
              即再从左向右，找第一个反括号，然后与右边第一个符号作比较，然后再判断
     到这里算法就已经完成了
     
在本道题中，我学会了：
1、empty（）函数的使用，用来作为if判断语句：if(!s.empty())
2、字符串是可以做减法的，如：s[i]-s[i-1]，这里是用字符的ASCLL码做减法
3、最重要的，我使用出错的一个地方：erase()函数的使用：
          erase（）函数的使用分为：用迭代器和直接使用，两种情况
          iterator erase(iterator p):删除迭代器P指向的字符，返回删除后的字符串        
          iterator erase (iterator first, iterator last);删除迭代器first到last范围内的字符，需要注意的是左闭右开
          string& erase(size_t pos=0, size_t len = npos);其中，
              参数pos表示要删除字符串的起始位置，其默认值是0；
              len表示要删除字符串的长度，其默认值是string::npos。返回值是删除后的字符串。
              注意：第一个参数是：起始位置，第二个参数是要删除的长度（类似于substr）
              
          代码示例：
          std::string str("This is an example sentence.");给出一段字符串
          str.erase(10, 8);         删除，起始位置是10，删除8个     这里没有用迭代器，所以是范围          
          str.erase(str.begin() + 9);          删除，位置是9的那个字符 （这里的位置是从0开始算的）
                  str.begin()是字符串的起始位置
          str.erase(str.begin() + 5, str.end() - 9);  删除，位置是5这里的位置是从0开始算的）的那个字符  到从右往左数第9个字符，左闭右开
          
    要注意：在字符串中，  空格   也算一个字符 


      

        
       
  
                  




